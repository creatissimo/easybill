<?php
/**
 * PostBoxRequest
 *
 * PHP version 5
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * easybill REST API
 *
 * The first version of the easybill REST API. [CHANGELOG](https://api.easybill.de/rest/v1/CHANGELOG.md)  ## Authentication  You can choose between two available methods: `Basic Auth` or `Bearer Token`.  In each HTTP request, one of the following HTTP headers is required:  ``` # Basic Auth Authorization: Basic base64_encode('<email>:<api_key>') # Bearer Token Authorization: Bearer <api_key> ```  ## Limitations  ### Request Limit  * PLUS: 10 requests per minute * BUSINESS: 60 requests per minute  If the limit is exceeded, you will receive the HTTP error: `429 Too Many Requests`  ### Result Limit  All result lists are limited to 100 by default. This limit can be increased by the query parameter `limit` to a maximum of 1000.  ## Query filter  Many list resources can be filtered. In `/documents` you can filter e.g. by number with `/documents?number=111028654`. If you want to filter multiple numbers, you can either enter them separated by commas `/documents?number=111028654,222006895` or as an array `/documents?number[]=111028654&number[]=222006895`.  **Warning**: The maximum size of an HTTP request line in bytes is 4094. If this limit is exceeded, you will receive the HTTP error: `414 Request-URI Too Large`  ### Escape commas in query  You can escape commans in query `name=Patrick\\, Peter` if you submit the header `X-Easybill-Escape: true` in your request.  ## Property login_id  This is the login of your admin or employee account.  ## Date and Date-Time format Please use the timezone `Europe/Berlin`. * **date** = *Y-m-d* = `2016-12-31` * **date-time** = *Y-m-d H:i:s* = `2016-12-31 03:13:37`  Date or datetime can be `null` because the attributes have been added later and the entry is older.
 *
 * OpenAPI spec version: 1.70.1
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 3.0.33
 */
/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Swagger\Client\Model;

use \ArrayAccess;
use \Swagger\Client\ObjectSerializer;

/**
 * PostBoxRequest Class Doc Comment
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class PostBoxRequest implements ModelInterface, ArrayAccess
{
    const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $swaggerModelName = 'PostBoxRequest';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $swaggerTypes = [
        'to' => 'string',
'cc' => 'string',
'from' => 'string',
'subject' => 'string',
'message' => 'string',
'date' => '\DateTime',
'document_file_type' => 'string',
'post_send_type' => 'string'    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $swaggerFormats = [
        'to' => null,
'cc' => null,
'from' => null,
'subject' => null,
'message' => null,
'date' => 'date',
'document_file_type' => null,
'post_send_type' => null    ];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function swaggerTypes()
    {
        return self::$swaggerTypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function swaggerFormats()
    {
        return self::$swaggerFormats;
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'to' => 'to',
'cc' => 'cc',
'from' => 'from',
'subject' => 'subject',
'message' => 'message',
'date' => 'date',
'document_file_type' => 'document_file_type',
'post_send_type' => 'post_send_type'    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'to' => 'setTo',
'cc' => 'setCc',
'from' => 'setFrom',
'subject' => 'setSubject',
'message' => 'setMessage',
'date' => 'setDate',
'document_file_type' => 'setDocumentFileType',
'post_send_type' => 'setPostSendType'    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'to' => 'getTo',
'cc' => 'getCc',
'from' => 'getFrom',
'subject' => 'getSubject',
'message' => 'getMessage',
'date' => 'getDate',
'document_file_type' => 'getDocumentFileType',
'post_send_type' => 'getPostSendType'    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$swaggerModelName;
    }

    const DOCUMENT_FILE_TYPE__DEFAULT = 'default';
const DOCUMENT_FILE_TYPE_ZUGFERD1 = 'zugferd1';
const DOCUMENT_FILE_TYPE_ZUGFERD2 = 'zugferd2';
const DOCUMENT_FILE_TYPE_XRECHNUNG = 'xrechnung';
const DOCUMENT_FILE_TYPE_XRECHNUNG_XML = 'xrechnung_xml';
const POST_SEND_TYPE_STANDARD = 'post_send_type_standard';
const POST_SEND_TYPE_REGISTERED = 'post_send_type_registered';
const POST_SEND_TYPE_REGISTERED_AND_PERSONAL = 'post_send_type_registered_and_personal';
const POST_SEND_TYPE_REGISTERED_AND_RECEIPT = 'post_send_type_registered_and_receipt';
const POST_SEND_TYPE_REGISTERED_THROWIN = 'post_send_type_registered_throwin';
const POST_SEND_TYPE_PRIO = 'post_send_type_prio';

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getDocumentFileTypeAllowableValues()
    {
        return [
            self::DOCUMENT_FILE_TYPE__DEFAULT,
self::DOCUMENT_FILE_TYPE_ZUGFERD1,
self::DOCUMENT_FILE_TYPE_ZUGFERD2,
self::DOCUMENT_FILE_TYPE_XRECHNUNG,
self::DOCUMENT_FILE_TYPE_XRECHNUNG_XML,        ];
    }
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getPostSendTypeAllowableValues()
    {
        return [
            self::POST_SEND_TYPE_STANDARD,
self::POST_SEND_TYPE_REGISTERED,
self::POST_SEND_TYPE_REGISTERED_AND_PERSONAL,
self::POST_SEND_TYPE_REGISTERED_AND_RECEIPT,
self::POST_SEND_TYPE_REGISTERED_THROWIN,
self::POST_SEND_TYPE_PRIO,        ];
    }

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->container['to'] = isset($data['to']) ? $data['to'] : null;
        $this->container['cc'] = isset($data['cc']) ? $data['cc'] : null;
        $this->container['from'] = isset($data['from']) ? $data['from'] : null;
        $this->container['subject'] = isset($data['subject']) ? $data['subject'] : null;
        $this->container['message'] = isset($data['message']) ? $data['message'] : null;
        $this->container['date'] = isset($data['date']) ? $data['date'] : null;
        $this->container['document_file_type'] = isset($data['document_file_type']) ? $data['document_file_type'] : null;
        $this->container['post_send_type'] = isset($data['post_send_type']) ? $data['post_send_type'] : null;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        $allowedValues = $this->getDocumentFileTypeAllowableValues();
        if (!is_null($this->container['document_file_type']) && !in_array($this->container['document_file_type'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'document_file_type', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getPostSendTypeAllowableValues();
        if (!is_null($this->container['post_send_type']) && !in_array($this->container['post_send_type'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'post_send_type', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets to
     *
     * @return string
     */
    public function getTo()
    {
        return $this->container['to'];
    }

    /**
     * Sets to
     *
     * @param string $to to
     *
     * @return $this
     */
    public function setTo($to)
    {
        $this->container['to'] = $to;

        return $this;
    }

    /**
     * Gets cc
     *
     * @return string
     */
    public function getCc()
    {
        return $this->container['cc'];
    }

    /**
     * Sets cc
     *
     * @param string $cc cc
     *
     * @return $this
     */
    public function setCc($cc)
    {
        $this->container['cc'] = $cc;

        return $this;
    }

    /**
     * Gets from
     *
     * @return string
     */
    public function getFrom()
    {
        return $this->container['from'];
    }

    /**
     * Sets from
     *
     * @param string $from from
     *
     * @return $this
     */
    public function setFrom($from)
    {
        $this->container['from'] = $from;

        return $this;
    }

    /**
     * Gets subject
     *
     * @return string
     */
    public function getSubject()
    {
        return $this->container['subject'];
    }

    /**
     * Sets subject
     *
     * @param string $subject subject
     *
     * @return $this
     */
    public function setSubject($subject)
    {
        $this->container['subject'] = $subject;

        return $this;
    }

    /**
     * Gets message
     *
     * @return string
     */
    public function getMessage()
    {
        return $this->container['message'];
    }

    /**
     * Sets message
     *
     * @param string $message message
     *
     * @return $this
     */
    public function setMessage($message)
    {
        $this->container['message'] = $message;

        return $this;
    }

    /**
     * Gets date
     *
     * @return \DateTime
     */
    public function getDate()
    {
        return $this->container['date'];
    }

    /**
     * Sets date
     *
     * @param \DateTime $date date
     *
     * @return $this
     */
    public function setDate($date)
    {
        $this->container['date'] = $date;

        return $this;
    }

    /**
     * Gets document_file_type
     *
     * @return string
     */
    public function getDocumentFileType()
    {
        return $this->container['document_file_type'];
    }

    /**
     * Sets document_file_type
     *
     * @param string $document_file_type When set to null, the setting on the customer is used
     *
     * @return $this
     */
    public function setDocumentFileType($document_file_type)
    {
        $allowedValues = $this->getDocumentFileTypeAllowableValues();
        if (!is_null($document_file_type) && !in_array($document_file_type, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'document_file_type', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['document_file_type'] = $document_file_type;

        return $this;
    }

    /**
     * Gets post_send_type
     *
     * @return string
     */
    public function getPostSendType()
    {
        return $this->container['post_send_type'];
    }

    /**
     * Sets post_send_type
     *
     * @param string $post_send_type This value indicates what method is used when the document is send via mail. The different types are offered by the german post as additional services. The registered mail options will include a tracking number which will be  added to the postbox when known.  If the value is omitted or empty when a postbox is created with the type \"POST\" post_send_type_standard will be used.  For postbox with a different type than \"POST\" this field will hold a empty string.
     *
     * @return $this
     */
    public function setPostSendType($post_send_type)
    {
        $allowedValues = $this->getPostSendTypeAllowableValues();
        if (!is_null($post_send_type) && !in_array($post_send_type, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'post_send_type', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['post_send_type'] = $post_send_type;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset)
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed
     */
    public function offsetGet($offset)
    {
        return isset($this->container[$offset]) ? $this->container[$offset] : null;
    }

    /**
     * Sets value based on offset.
     *
     * @param integer $offset Offset
     * @param mixed   $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value)
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset)
    {
        unset($this->container[$offset]);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        if (defined('JSON_PRETTY_PRINT')) { // use JSON pretty print
            return json_encode(
                ObjectSerializer::sanitizeForSerialization($this),
                JSON_PRETTY_PRINT
            );
        }

        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}
